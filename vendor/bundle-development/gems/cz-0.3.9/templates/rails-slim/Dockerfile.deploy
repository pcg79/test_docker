# vim: ft=Dockerfile

# All images should be based upon alpine, if possible. If you require libraries
# that don't work in alpine (they need glibc, for instance) an acceptable
# alternative is slim.
FROM ruby:2.3.3-slim

# Install dependencies you'll need to run your app in production or staging. The
# app will already have been built, so you don't need to (and shouldn't) install
# build tools here. For slim, we'll need to add the apt.postgresql.org repo for
# an updated PostgreSQL client compatible with 9.6 servers.
RUN set -ex && \
    apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 \
      --recv-keys B97B0AFCAA1A47F044F244A07FCC7D46ACCC4CF8 && \
      echo "deb http://apt.postgresql.org/pub/repos/apt/ jessie-pgdg main" \
      > /etc/apt/sources.list.d/pgdg.list && \
    apt-get update && \
    apt-get install -qq -y --no-install-recommends \
      nodejs \
      postgresql-client-9.6 \
      curl

# The default Ruby image has an annoying gem/bundler environment. We override
# it so that when you install gems within the container, they'll end up in your
# app's vendor/bundle directory, for copying to our deployment image, and to
# separate them from any local installations on your machine.
ENV BUNDLE_PATH="/opt/app/vendor/bundle" \
    BUNDLE_BIN="/opt/app/vendor/bundle/bin" \
    BUNDLE_SILENCE_ROOT_WARNING=1 \
    BUNDLE_WITHOUT="development:test" \
    BUNDLE_FORCE_RUBY_PLATFORM=1
ENV PATH $BUNDLE_BIN:$PATH

# Ensure /opt exists, and add `app` user and `app` group, then ensure the `app`
# user has membership in a newly-created `vault` group. This group is used to
# provide non-root users access to secrets stored in your app's vault.
RUN /usr/sbin/addgroup vault && \
    /usr/sbin/adduser \
      --home /opt/app \
      --shell /bin/sh \
      --gecos app \
      --disabled-password \
      app && \
    /usr/sbin/addgroup app vault && \
    gem install bundler -v 1.14.6

# For Rails apps, we'll copy the entire project into the image. For binaries,
# we might just copy the binaries themselves.
COPY . /opt/app

# By default, everything we just copied will be owned by `root. That's not what
# we want. But, since `chown` will create a new layer with every file we change,
# we don't want to mess with ownership of files we don't need to. Ignoring the
# often-huge and should-be-world-readable nature of `vendor`, we exclude it.
RUN find /opt/app -maxdepth 1 -mindepth 1 -name vendor -prune -o -print0 | \
    xargs -0 /bin/chown -R app:app

# It's strongly recommended that you don't run your app as `root` by default.
# If you need assistance in getting your app running with lesser permissions,
# DevX is happy to help!
USER app

# DO NOT REMOVE. WORKDIR for starting your application and running most anything
# else should always be `/opt/app`.
WORKDIR /opt/app

# DO NOT CHANGE. This is where we customize the environment provided to your app
# based on the (possibly) supplied $ENVIRONMENT environment variable.
ENTRYPOINT ["cz/environment"]

# DO NOT CHANGE. When deployed, this is the script that we expect to use to
# launch your app.
CMD ["cz/start"]

# DO NOT CHANGE.
# When we build images, we pass in some arguments so the containers have some
# information about the app they're running in their environment. This can be
# useful for logging, reporting that a container's been started in its `start`
# script, or any number of other places in your app.
ARG CZ_APP_NAME
ARG CZ_APP_VERSION
ARG CZ_BUILD_ENVIRONMENT
ENV CZ_APP_NAME=${CZ_APP_NAME:-<%= app_name %>} \
    CZ_APP_VERSION=${CZ_APP_VERSION:-unspecified} \
    CZ_BUILD_ENVIRONMENT=${CZ_BUILD_ENVIRONMENT:-unspecified}
