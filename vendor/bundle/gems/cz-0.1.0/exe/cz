#!/usr/bin/env ruby

require 'yaml'
require 'parallel'
require 'date'

require 'rubygems'
require 'rubygems/package'
require 'rubygems/package/tar_writer'

require 'base64'
require 'erb'
require 'fileutils'
require 'find'
require 'gpgme'
require 'net/ssh'
require 'shellwords'

class CZ
  attr_accessor :command, :environment, :options, :rest, :switch_commits,
                :target_sha, :working_dir

  def initialize(command)
    @command = (command || 'help').downcase
  end

  def run(*rest)
    # set options here?
    # @options     = extract_options!

    self.send(command.to_sym, *rest)
  end

  def init(template = "default")
    app_name = File.basename(working_dir)
    template_dir = File.realpath(
      File.expand_path("../../templates/#{template}", __FILE__)
    )
    Find.find(template_dir).map { |path|
      [path, path.sub(/.*?templates\/#{template}\//, '')]
    }.each do |orig, dest|
      next if orig == dest # Skip if toplevel dir
      if File.directory?(orig)
        FileUtils.mkdir(dest) unless File.directory?(dest)
        File.chmod(file_mode(orig), dest)
      else
        if !File.exist?(dest) || ask("Would you like to overwrite #{dest}?")
          File.write(dest, ERB.new(File.read(orig)).result(binding))
          File.chmod(file_mode(orig), dest)
        else
          puts "Skipping #{dest}."
        end
      end
    end
  end

  def file_mode(path)
    File.stat(path).mode
  end

  def ask(prompt)
    print "#{prompt} (y/N) "
    answer = $stdin.gets.chomp
    answer.downcase[0] == "y"
  end

  def build(environment)
    @environment = environment.downcase
    @target_sha  = current_sha

    check_environment!

    sanity_checks

    puts "Packing image in '#{working_dir}' using sha #{current_sha}"

    build_and_tag_image
    push_to_index

    puts "\nPackage complete.  To deploy, run: #{File.basename($0)} deploy #{environment} #{current_sha}"
  end

  def deploy(environment, target_sha=current_sha)
    @environment = environment
    @target_sha  = target_sha

    check_environment!

    if target_servers.empty?
      abort_with_message "No hosts configured for #{@environment}! Exiting."
    end


    global_pre_deploy

    pre_deploy_hooks

    run_once_hook

    target_servers.each do |target_server|
      puts "Starting new container on #{target_server}..."
      stdout, stderr, = run_ssh target_server, receive_deploy('start')
      puts [stdout, stderr].join
      puts "Deploy completed on #{target_server}"
      puts
    end

    post_deploy_hooks

    health_check_hooks

    puts
    puts "Successfully deployed #{image_with_tag} (#{target_sha})"
  end

  def vault(subcommand, *rest)
    self.send("vault_#{subcommand}", *rest)
  end

  def vault_sanity_checks
    missing = recipient_map.inject([]) { |missing, (email, keys)|
      missing << email if keys.empty?
      missing
    }
    unless missing.empty?
      abort_with_message "You don't have public GPG keys for the following developers:\n#{missing.map {|d| "  - #{d}"}.join("\n")}"
    end

    test = crypto.encrypt("test", recipients: recipient_keys, always_trust: true)
    crypto.decrypt(test)
  rescue GPGME::Error::DecryptFailed
    abort_with_message <<MESSAGE
You do not have a private key suitable for decrypting any data you would
encrypt! Please ensure that your private key is in your GPG keyring, and that
an e-mail associated with it is in your cz.yml "developers:" section.
MESSAGE
  end

  def vault_encrypt
    vault_sanity_checks

    encrypt(decrypted_vault)
  end

  def vault_del(environment, key)
    vault_sanity_checks

    @environment = environment

    check_environment!

    decrypted_vault[environment].delete(key)
    encrypt(decrypted_vault)
  end

  def vault_set(environment, key, value = nil)
    vault_sanity_checks

    @environment = environment

    check_environment!

    value ||= $stdin.read

    env_hash = decrypted_vault.fetch(environment, {})
    env_hash[key] = value
    decrypted_vault[environment] = env_hash
    encrypt(decrypted_vault)
  end

  def vault_spec
    @vault_spec ||= YAML.load_file("deploy.yml").fetch("vault", []).map { |file|
      {
        key: file["key"],
        path: file["path"] && Shellwords.escape(file["path"].strip.gsub(/(\A|\/)?\.{2}(\/|\z)/, '\1')),
        mode: file["mode"].to_s.match(/\A[0-9]{3,4}\z/) && file["mode"]
      }
    }.select { |file|
      !file[:key] || !file[:key].empty? || !file[:path] || !file[:path].empty?
    }
  end

  def vault_unpack
    items = decrypted_vault.fetch("development", {})
    if vault_spec.empty?
      items.each do |key, value|
        File.write("vault/#{key}", value)
      end
    else
      mkdir = Hash.new do |h, k|
        begin
          FileUtils.mkdir("vault/#{k}")
        rescue Errno::EEXIST
        end
        h[k] = true
      end
      vault_spec.each do |file|
        if items.key?(file[:key])
          path, name = File.split(file[:path])
          path.split("/").inject([]) { |dirs, dir|
            mkdir[File.join(*dirs, dir)]
            dirs << dir
          }
          File.write("vault/#{file[:path]}", items[file[:key]])
        else
          $stderr.puts(
            "Skipping unpack of '#{file[:path]}':\n  No key '#{file[:key]}' in the 'development' vault."
          )
        end
      end
    end
    puts "Development vault unpacked!"
  end

  def vault_get(environment, key)
    @environment = environment

    check_environment!

    puts decrypted_vault[environment][key]
  end

  def help
    help = <<HELP

Usage:  build COMMAND

A quick and dirty util for building, running, and deploying docker-based apps

Management Commands:
  init                                         Initialize an app for deployment using this script
  build ENVIRONMENT                            Package the deploy image using HEAD
  deploy ENVIRONMENT [TARGET_SHA]              Deploy to ENVIRONMENT the deploy image that was created with TARGET_SHA or HEAD
  vault set ENVIRONMENT KEY [VALUE] [< VALUE]  Set the KEY/VALUE pair under ENVIRONMENT in the vault
  vault get ENVIRONMENT KEY                    Print the value of KEY under ENVIRONMENT from the vault
  vault del ENVIRONMENT KEY                    Remove the KEY under ENVIRONMENT from the vault
  vault encrypt                                Re-encrypt a vault using recipients list from cz.yml
  vault unpack                                 Creates the filesystem for the development environment

  help                 This message
HELP

    puts help
  end

  private

  def build_and_tag_image
    puts "Building and tagging images.  Please be patient - this may take a while."

    build_dev_image
    build_deploy_image
  end

  # We build the dev image because the deploy image is based off of it.
  # Dockerfile.deploy does not contain the tools needed to a full build (it can't
  # `bundle install`, for example).
  def build_dev_image
    run_command "docker build --build-arg CZ_APP_NAME=#{app} -t #{app}-dev -f Dockerfile.dev ."
  end

  def build_deploy_image
    run_command "docker run --rm -v #{working_dir}:/opt/app -e ENVIRONMENT=#{environment} -e BUILD_TARGET=deploy #{app}-dev cz/build"
    run_command "docker build --build-arg CZ_APP_NAME=#{app} --build-arg CZ_APP_VERSION=#{target_sha} -t #{image_with_tag} -f Dockerfile.deploy ."
  end

  def push_to_index
    puts "Pushing #{target_sha} to #{image_with_tag}"

    run_command "gcloud docker -- push #{image_with_tag}"

    puts "Pushed successfully"
  end

  def sanity_checks
    return if skip_checks?

    check_git_status
    check_target_sha_on_master
    run_command_silently "which docker", "You need docker installed to run this.  Aborting."
    run_command_silently "which gcloud", "You need gcloud installed and initialized (https://docs.google.com/document/d/1EiPPrerkADJfoS0V7mcVlCg2w07A0AeOkVOZrJlJzh8) to run this.  Aborting."
    run_command_silently "docker info", "You need to start the docker daemon and try again.  Aborting."
  end

  def check_git_status
    result = `git status`
    puts result

    case result
    when /Your branch is behind/
      abort_with_message "You do not have the latest code.  Please pull first and try again.  Aborting."
    when /Your branch is ahead/
      abort_with_message "Origin doesn't have your latest code.  Please push first and try again.  Aborting."
    when /working tree clean/
      puts "Git status is clean."
    else
      abort_with_message "Git status is not clean.  Please commit your changes before deploying and try again.  Aborting."
    end
  end

  def check_target_sha_on_master
    # Verify SHA has been pushed to origin/master (for prod) or any origin (for staging)
    cmd = "git branch -r --contains #{target_sha}"
    error_msg = "This commit doesn't exist on "

    if environment == 'production'
      cmd << " | grep origin/master"
      error_msg << "origin/master.  "
    else
      error_msg << "any branches on origin.  "
    end

    error_msg << "Please push it before continuing.  Aborting."

    run_command_silently cmd, error_msg
  end

  def checkout_sha
    `git checkout #{target_sha}`
    if $?.exitstatus.nonzero?
      abort_with_message "Error checking out #{target_sha}.  Aborting."
    end
  end

  def current_sha
    @current_sha ||= `git rev-parse --short HEAD`.chomp
  end

  def check_environment!
    if !valid_environment?
      abort_with_message "ENVIRONMENT must be one of the following: #{environment_whitelist.join(', ')}"
    end
  end

  def valid_environment?
    environment_whitelist.include? environment
  end

  # This may be app-dependent.  Execute a file?
  def global_pre_deploy
    puts "Running global pre-deploy..."

    today = Date.today
    if !today.friday? ||
      ask("\nIt's Friday.  Are you sure you want to deploy on a Friday?")
      # all good.
    else
      abort_with_message "Aborting"
    end

    puts "Global pre-deploy finished successfully"
  end

  def pre_deploy_hooks
    vault = YAML.dump(decrypted_vault.fetch(environment, {}))

    puts "Running pre-deploy hooks on the target servers..."
    results = Parallel.map(target_servers) do |target_server|
      stdout, stderr, code, _signal = run_ssh(
        target_server, receive_deploy('pre-deploy'), stdin: vault
      )
      puts "#{target_server}: #{[stdout, stderr].join}"

      rarray = [target_server, [stdout, stderr].join, code]
    end

    failed_results = results.select { |result| result[-1].nonzero? }

    if failed_results.empty?
      puts "Pre-deploy successful"
    else
      error_str = failed_results.map { |r| [ r[0], r[1] ].join(": ") }.join
      abort_with_message "There were errors during pre-deploy (see below).  Deployment FAILED.  Aborting.\n\n#{error_str}"
    end
  end

  def run_once_hook
    run_once_server = target_servers[0]
    puts "Running run-once hook on #{run_once_server}..."

    stdout, stderr, code, _signal = run_ssh(
      run_once_server, receive_deploy('run-once')
    )

    if code.nonzero?
      abort_with_message "There were errors during run-once hook.  Deployment FAILED.  Aborting.\n\n#{[stdout, stderr].join}"
    else
      puts "Run-once hook finished successfully"
    end
  end

  def post_deploy_hooks
    puts "Running post-deploy hooks on the target servers..."
    results = Parallel.map(target_servers) do |target_server|
      stdout, stderr, code, _signal = run_ssh(
        target_server, receive_deploy('post-deploy')
      )
      puts "#{target_server}: #{stdout}"

      rarray = [target_server, [stdout, stderr].join, code]
    end

    failed_results = results.select { |result| result[-1].nonzero? }

    if failed_results.empty?
      puts "Post-deploy successful"
    else
      error_str = failed_results.map { |r| [ r[0], r[1] ].join(": ") }.join
      abort_with_message "There were errors during post-deploy (see below).  Deployment FAILED.  Aborting.\n\n#{error_str}"
    end
  end

  def health_check_hooks
    # TODO: Set up health check when running `start` command,
    #   and loop while checking `docker ps` output for health info here
  end

  def ssh_exec!(ssh, command, stdin: nil)
    stdout_data = ""
    stderr_data = ""
    exit_code = nil
    exit_signal = nil
    ssh.open_channel do |channel|
      channel.exec(command) do |ch, success|
        unless success
          abort "FAILED: couldn't execute command (#{command})"
        end
        channel.on_data do |ch,data|
          stdout_data << data
        end

        channel.on_extended_data do |ch,type,data|
          stderr_data << data
        end

        channel.on_request("exit-status") do |ch,data|
          exit_code = data.read_long
        end

        channel.on_request("exit-signal") do |ch, data|
          exit_signal = data.read_long
        end

        if stdin
          channel.send_data stdin
          channel.eof!
        end
      end
    end
    ssh.loop
    [stdout_data, stderr_data, exit_code, exit_signal]
  end

  def run_ssh(host, command, stdin: nil)
    stdout = stderr = code = signal = nil
    Net::SSH.start(host) do |ssh|
      stdout, stderr, code, signal = ssh_exec!(ssh, command, stdin: stdin)
    end
    abort_with_message "Error running command (#{command}). Exiting" unless code.zero?
    [stdout, stderr, code, signal]
  end

  def run_command(command, failure_message="Error running command. Aborting.", silent=false)
    puts "#{command}" unless silent

    results = `#{command}`
    puts results unless silent

    if $?.exitstatus.nonzero?
      abort_with_message failure_message
    end
  end

  def receive_deploy(command)
    "sudo receive-cz-deploy #{command} #{receive_deploy_params}"
  end

  def receive_deploy_params
    "#{environment} #{app} #{image} #{target_sha} 2>&1"
  end

  def decrypted_vault
    return @hash if defined? @hash

    yaml = YAML.load_file("./vault.yml")

    @hash = { "developers" => yaml.delete("developers") }

    yaml.keys.each do |env|
      @hash[env] = Hash[
        yaml[env].map { |k,v|
          [k, decrypt_value(v)]
        }
      ]
    end

    @hash
  rescue Errno::ENOENT
    @hash = { "developers" => recipients }
  end

  def encrypt(decrypted_hash)
    new_hash   = { "developers" => recipients }

    (decrypted_hash.keys - ["developers"]).sort.each do |env|
      new_hash[env] = Hash[
        decrypted_hash[env].sort { |(ka, _), (kb, _)| ka <=> kb }.map { |k, v|
          [k, encrypt_value(v)]
        }
      ]
    end

    File.open('vault.yml', 'w') do |file|
      file.write(YAML.dump(new_hash))
    end
  end

  def decrypt_value(value)
    crypto.decrypt(Base64.decode64(value)).to_s
  end

  def encrypt_value(value)
    Base64.encode64(crypto.encrypt(value, recipients: recipient_keys, always_trust: true).to_s).chomp
  end

  def run_command_silently(command, failure_message)
    run_command command, failure_message, true
  end

  def abort_with_message(message)
    abort message
  end

  def image
    config['image']
  end

  def image_with_tag
    "#{image}:#{target_sha}"
  end

  def skip_checks?
    true
    # options.include? '--skip-checks'
  end

  def extract_options!
    rest.map do |param|
      rest.delete(param) if param.start_with?('-')
    end.compact
  end

  def working_dir
    @working_dir ||= Dir.pwd
  end

  def environment_whitelist
    config["environments"].keys + ["development"]
  end

  def app
    config['app']
  end

  def target_servers
    config["environments"].fetch(environment, {}).fetch('hosts', [])
  end

  def config
    @config ||= YAML.load_file('./cz.yml')
    # Do sanity checks against config file?
  end

  def crypto
    @crypto ||= GPGME::Crypto.new
  end

  def recipients
    @recipients ||= config['developers']
  end

  def recipient_keys
    @recipient_keys ||= recipient_map.values.flatten
  end

  def recipient_map
    @recipient_map ||= Hash[
      config['developers'].map { |email|
        [email, GPGME::Key.find(:public, email)]
      }
    ]
  end

end


command, *rest = ARGV

CZ.new(command).run(*rest)
